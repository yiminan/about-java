package elegantobject.step4_retirement.step4_1_neverreturnnull;

/**
 * "빠르게 실패하기(Fail Fast) vs. 안전하게 실패하기(Fail Safe)"<p>
 * <p>
 * 소프트웨어 견고성(software robustness)와 실패 탄력회복성(failure resilience)이라는 상반된 철학이 존재합니다.<p>
 * 그것이 빠르게 실패하기와 안전하게 실패하기입니다.<p>
 * 둘 다 장단점이 있지만, 보통 '빠르게 실패하기' 진영에서는 안전하게 실패하기를 반대합니다.<p>
 * <p>
 * '안전하게 실패하기(Fail Safe)'<p>
 * - 버그, 입출력 문제, 메모리 오버플로우 등이 발생한 상황에도 소프트웨어를 지속시킵니다.<p>
 * - 어떤 상황에서도 소프트웨어는 생존하도록 만듭니다.<p>
 * - 소프트웨어를 생존시키기 위해서 사용한 것이 null 반환 기법입니다.<p>
 * - null을 반환하고 반환받은 주체가 잘 처리해서 소프트웨어가 지속처리되길 기대합니다.<p>
 * <p>
 * '빠르게 실패하기(Fail Fast)'<p>
 * - 일단 문제가 발생하면 곧바로 실행을 중단하고, 최대한 빨리 예외를 던집니다.<p>
 * - 소프트웨어가 단일 제어 지점(single control point)에서 중단되도록 설계되면, 실패 상황을 손쉽게 재현할 수 있습니다.<p>
 * - 실패 상황이 손쉽게 재현되면 테스트를 통해서 실패 부분을 테스트 케이스로 잡아갈 수 있습니다.<p>
 * - 상황을 구조하지 않는 대신, 가능하면 실패를 분명하게(flagrant) 만듭니다.<p>
 * - 만약 요청자가 잘못된 디렉토리 위치를 제공했다면, 이 실수에 대한 비용은 요청자가 지불하게 만들어야합니다.<p>
 * - 예를 들면, 요청자는 API 직접 사용하는 주체입니다.<p>
 * <p>
 * 소프트웨어의 에러를 즉시 발견하고 확인하는 경우에는 안전성과 견고함을 얻을 수 있습니다.<p>
 * 빠르게 문제를 찾을 수록 더 빠르게 실패하고 결과적으로 전체적인 소프트웨어의 품질이 향상됩니다.<p>
 * 오히려 실패를 오래 숨길수록 나중에 더 큰 문제로 발전하게 됩니다.<p>
 */
class FailFastVsFailSafe {

}
